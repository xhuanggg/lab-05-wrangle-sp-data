---
title: "Lab 05 - La Quinta is Spanish for next to Denny's, Pt. 2"
author: "Thomas Huang"
date: "2026-02-06"
output: github_document
---

### Load packages and data

```{r load-packages, message = FALSE}
library(tidyverse) 
library(dsbox) 
library(ggridges)
```

```{r load-data, message = FALSE}
states <- read_csv("data/states.csv")
data(dennys, package = "dsbox")
data(laquinta, package = "dsbox")
```

### Exercise 1

There are three Denny's and two La Quinta in Alaska.
```{r Ex1}
dn_ak <- dennys %>%
  filter(state == "AK")
nrow(dn_ak)

lq_ak <- laquinta %>%
  filter(state == "AK")
nrow(lq_ak)
```

### Exercise 2

There are three Denny's and two La Quinta in Alaska. Each Denny's corresponds to two La Quinta. Therefore, there should be $$3\times2=6$$ pairs.

### Exercise 3

```{r Ex3}
dn_lq_ak <- full_join(dn_ak, lq_ak,
  by = "state"
)
dn_lq_ak
```

### Exercise 4

There are six observations in this data frame. The variable are street address, city, state, zip code, longitude, and latitude of each Denny's and La Quinta.
```{r Ex4}
glimpse(dn_lq_ak)
```

### Exercise 5

dplyr::mutate(new_var = ...) can be used to create a new variable.
```{r Ex5}
# Define a cool function that calculates the distance between any two points on the earth.
haversine <- function(long1, lat1, long2, lat2, round = 3) {
  # convert to radians
  long1 <- long1 * pi / 180
  lat1 <- lat1 * pi / 180
  long2 <- long2 * pi / 180
  lat2 <- lat2 * pi / 180

  R <- 6371 # Earth mean radius in km

  a <- sin((lat2 - lat1) / 2)^2 + cos(lat1) * cos(lat2) * sin((long2 - long1) / 2)^2
  d <- R * 2 * asin(sqrt(a))

  return(round(d, round)) # distance in km
}
```

### Exercise 6

```{r Ex6}
dn_lq_ak <- dn_lq_ak %>% 
  dplyr::mutate(
    distance = haversine(longitude.x, latitude.x, longitude.y, latitude.y)
  )

glimpse(dn_lq_ak)
```

### Exercise 7

```{r Ex7}
dn_lq_ak <- dn_lq_ak %>% 
  group_by(address.x) %>% 
  mutate(min_distance = min(distance))
```

### Exercise 8

```{r Ex8}
# Summary stats
psych::describe(dn_lq_ak$min_distance)

ggplot(data = dn_lq_ak, aes(x = min_distance)) +
  geom_histogram()
```

### Exercise 9

```{r Ex9-Def-Function}
state_function <- function(state_abbr){
  dn_state <- dennys %>%
  filter(state == state_abbr)

  lq_state <- laquinta %>%
  filter(state == state_abbr)
  
  dn_lq_state <- full_join(dn_state, lq_state,
    by = "state"
  ) %>% 
    dplyr::mutate(
      distance = haversine(longitude.x, latitude.x, longitude.y, latitude.y)
    ) %>% 
    group_by(address.x) %>% 
    mutate(min_distance = min(distance))
  
  psych::describe(dn_lq_state$min_distance)
  ggplot(data = dn_lq_state, aes(x = min_distance)) +
    geom_density()
}
```

```{r Ex9-NC}
state_function("NC")
```

### Exercise 10

```{r Ex10-TX}
state_function("TX")
```

### Exercise 11

I chose New York for this exercise.
```{r Ex11-NY}
state_function("NY")
```

### Exercise 12

I think the joke is mostly true. It's easy to find a La Quinta close to a Denny's.

### Exercise 13

The distribution of minimum distance varies by state. Such distributions in Nevada, New Mexico, and North Dakota is approximately normal. But such distributions follow a bi-modal distribution in states like New York, New Hampshire, and Nebreska. It is possible that there are two or more metropolitan areas in these states.
```{r Ex13}
# Create an empty data frame
df <- data.frame(
  state = character(),
  min_distance = numeric()
)

# Create a list of states
states <- list("NY", "NV", "NM", "NJ", "NH", "NE", "ND", "NC")

# Define another state function
state_function_2 <- function(state_abbr){
  
  dn_state <- dennys %>%
  filter(state == state_abbr) 

  lq_state <- laquinta %>%
  filter(state == state_abbr)
  
  dn_lq_state <- full_join(dn_state, lq_state,
    by = "state"
  ) %>% 
    dplyr::mutate(
      distance = haversine(longitude.x, latitude.x, longitude.y, latitude.y)
    ) %>% 
    group_by(address.x) %>% 
    mutate(min_distance = min(distance)) %>% 
    dplyr::select(state, min_distance)
  
  return(dn_lq_state)

}

# Loop over to calculate the min distances in the list of states
for (state in states){
  dn_lq_state <- state_function_2(state)
  df <- rbind(df, dn_lq_state)
}

ggplot(df, aes(x = min_distance, y = state)) + 
  geom_density_ridges(fill = "lightblue")
```

### Exercise 14

I played with color and width of the bars. But they are not as good as they were in the first place.
```{r Ex14}
# Source pattern: https://stackoverflow.com/a/36149654
# Posted by inscaven
# Retrieved 2026-02-08, License - CC BY-SA 3.0

library(usmap) #import the package
library(tidyverse)
library(usmap)
library(ggplot2)
library(sf)
library(grid)

 dn <- dennys
 lq <- laquinta

# 1) Closest La Quinta distance for each Denny's (all states)
dn_lq_full <- full_join(
  dn, lq,
  by = "state",
  suffix = c(".d", ".l")
) %>%
  filter(!is.na(latitude.d) & !is.na(latitude.l)) %>%
   filter(!state %in% c("AK", "HI")) 

dn_lq_full_mindist <- dn_lq_full %>%
  group_by(address.d) %>%
  mutate(distance = haversine(longitude.d, latitude.d, longitude.l, latitude.l)) %>%
  summarize(
    closest = min(distance, na.rm = TRUE),
    state   = first(state),
    .groups = "drop"
  )

# 2) Per-state binned distributions (these become the embedded mini bar charts)
binwidth_m <- 25

# Cap extreme tail so small charts remain legible
x_cap <- as.numeric(quantile(dn_lq_full_mindist$closest, 0.99, na.rm = TRUE))
x_max <- ceiling(x_cap / binwidth_m) * binwidth_m

state_bins <- dn_lq_full_mindist %>%
  mutate(
    closest_cap = pmin(closest, x_max),
    bin_left    = floor(closest_cap / binwidth_m) * binwidth_m,
    bin_mid     = bin_left + binwidth_m / 2
  ) %>%
  count(state, bin_mid, name = "n")

y_max <- max(state_bins$n, na.rm = TRUE)

# 3) US map as sf + centroids 
states_sf <- usmap::us_map(regions = "states") 

state_centroids <- states_sf %>%
  st_centroid() %>%
  mutate(
    x = st_coordinates(.)[, 1],
    y = st_coordinates(.)[, 2]
  ) %>%
  st_drop_geometry() %>%
  transmute(state = abbr, x = x, y = y)

# Bounding box for scaling embedded plot sizes
bb <- st_bbox(states_sf)
x_range <- as.numeric(bb["xmax"] - bb["xmin"])
y_range <- as.numeric(bb["ymax"] - bb["ymin"])

# Size of embedded mini-plots in map coordinate units
dx <- x_range * 0.04
dy <- y_range * 0.04

# 4) Base map
base_map <- ggplot() +
  geom_sf(data = states_sf, fill = "white", color = "gray60", linewidth = 0.2) +
  coord_sf(clip = "off") +
  theme_void()

# 5) Build one mini-plot per state and place it at the state's centroid
annotation_list <- purrr::pmap(
  list(state_centroids$state, state_centroids$x, state_centroids$y),
  function(st, cx, cy) {
    st_dat <- state_bins %>% filter(state == st)
    if (nrow(st_dat) < 2) return(NULL)
    
    mini <- ggplot(st_dat, aes(x = bin_mid, y = n)) +
      geom_col(color = "blue", fill = "blue", linewidth = 0.2, width = 1) +
      scale_x_continuous(limits = c(0, x_max), expand = c(0, 0)) +
      scale_y_continuous(limits = c(0, y_max), expand = c(0, 0)) +
      theme_void() +
      theme(
        plot.background = element_rect(fill = scales::alpha("white", 0.3), color = NA),
        plot.margin = margin(1, 1, 1, 1)
      )
    
    annotation_custom(
      grob = ggplotGrob(mini),
      xmin = cx - dx, xmax = cx + dx,
      ymin = cy - dy, ymax = cy + dy
    )
  }
)

annotation_list <- purrr::compact(annotation_list)

result_plot <- Reduce(`+`, annotation_list, base_map)



ggsave(
  result_plot,
  filename = "img/histogram-map.png",
  width = 10, height = 6, units = "in", dpi = 300
)
```


